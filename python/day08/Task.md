# Объектная модель Python
## Contents

1. [Информация об объектах](#информация-об-объектах)
2. [Сравниваем треугольники](#сравниваем-треугольники)
3. [Геометрическая прогрессия](#геометрическая-прогрессия)
4. [Множатся улыбки](#множатся-улыбки)

## Информация об объектах
Файл - ```day08_task01.py```

Напишите класс Shared, экземпляры которого будут обладать следующими свойствами: При выводе с помощью print() должно выводиться строка вида «|objects/live/total/local|, где objects — количество созданных за всё время экземпляров класса Shared (без учёта их удаления), live — количество актуальных экземпляров класса Shared, total — сколько всего операций «~» применялось к объектам класса Shared, а local — сколько операций «~» применялось к данному объекту Операция ~объект должна возвращать число local (уже увеличенное на 1 ☺)

### Примеры

Входные данные
```
b, c = Shared(), Shared()
print(b, c, Shared())
print(~c, ~b, ~c)
print(b, c)
```
Результат работы
```
|3/3/0/0| |3/3/0/0| |3/3/0/0|
1 1 2
|3/2/3/1| |3/2/3/2|
```

## Сравниваем треугольники
Файл - ```day08_task02.py```

Написать класс Triangle, моделирующий треугольник: объект tri типа Triangle создаётся из трёх вещественных чисел — сторон треугольника tri пуст, если не выполняется строгое неравенство треугольника или хотя бы одна из сторон не положительна abs(tri) — площадь треугольника (0, если tri пуст) два объекта tri1 и tri2 типа Triangle равны, только если попарно равны их стороны (в некотором порядке) равенство необходимо определять с помощью isclose() сравнение на неравенство двух объектов типа Triangle есть результат сравнения их площадей (независимо от того, равны ли треугольники в указанном выше смысле) (на всякий случай) площадь вычисляется по формуле Герона строковое представление: a:b:c, где a, b и c — это стороны треугольника в порядке их задания

### Примеры

Входные данные
```
tri = Triangle(3, 4, 5), Triangle(5, 4, 3), Triangle(7, 1, 1), Triangle(5, 5, 5), Tria  ngle(7, 4, 4)
for a, b in zip(tri[:-1], tri[1:]):
    print(a if a else b)
    print(f"{a}={abs(a):.2f} {b}={abs(b):.2f}")
    print(a == b)
    print(a >= b)
    print(a < b)
```
Результат работы
```
3.0:4.0:5.0
3.0:4.0:5.0=6.00 5.0:4.0:3.0=6.00
True
True
False
5.0:4.0:3.0
5.0:4.0:3.0=6.00 7.0:1.0:1.0=0.00
False
True
False
5.0:5.0:5.0
7.0:1.0:1.0=0.00 5.0:5.0:5.0=10.83
False
False
True
5.0:5.0:5.0
5.0:5.0:5.0=10.83 7.0:4.0:4.0=6.78
False
True
```

## Геометрическая прогрессия
Файл - ```day08_task03.py```

Напишите класс Geom(база, знаменатель), задающий геометрическую прогрессию, нумерация членов которой идёт с нуля. Сконструированный объект — бесконечная вычислимая последовательность, поддерживающая итерацию, индексирование и секционирование (в том числе конструкции с умолчаниями). Дополнительно должно поддерживаться секционирование вида прогрессия[начало, ..., конец], что соответствует конструкции прогрессия[начало:конец], причём параметр «начало ,» и/или «, конец» можно опускать. Индексирование должно возвращать соответствующий член прогрессии, а секционирование — последовательность членов (возможно, бесконечную). Конструкция прогрессия[::отрицательный шаг] возвращает пустую последовательность. Известно, что база и знаменатель однотипны (проверять не надо), того же типа должны быть и члены последовательности.

### Примеры

Входные данные
```
g = Geom(3, 2)
print(*zip("012345", g))
print(*g[:6])
print(*g[10::-2])
print(*zip(g[...], "0123"))
print(*g[3, ..., 11])
```
Результат работы
```
('0', 3) ('1', 6) ('2', 12) ('3', 24) ('4', 48) ('5', 96)
3 6 12 24 48 96
3072 768 192 48 12 3
(3, '0') (6, '1') (12, '2') (24, '3')
24 48 96 192 384 768 1536 3072
```

## Множатся улыбки
Файл - ```day08_task04.py```

Операции. Класс должен поддерживать унарный минус, вычисление модуля (abs()), сложение и вычитание смайликов, а также умножение смайлка на число: эти операции производятся над размером смайлика и возвращают новый объект (модуль возвращает целое число). Строковое представление. Смайлик нулевого размера — пустая строка. Смайлик единичного размера приведён в примере. При увеличении на 1 в смайлик добавляется строка и два столбца. Расстояние до «глаз» (сверху, справа и слева) и до «рта» снизу) — целая часть от четверти модуля смайлика. Расстояние до «рта» слева и справа — на одно знакоместо больше. В первой позиции нулевой строки отображается модуль смайлика. Смайлик отрицательного размера перевёрнут (только позиция модуля не изменяется). Конкретные символы, из которых состоит «смайлик», приведены ниже.

### Примеры

Входные данные
```
print(abs(Smile(-2)))
print(Smile(1))
print(Smile(1) - Smile(4))
print(-Smile(2) + Smile(-2))
print(Smile(6) * 3 - Smile(1))
```
Результат работы
```
2
/1\
|"|
\-/
/3----\
| --- |
|     |
|O   O|
\-----/
/4------\
|       |
|  ---  |
| O   O |
|       |
\-------/
/17-------------------------------\
|                                 |
|                                 |
|                                 |
|                                 |
|    O                       O    |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|                                 |
|     -----------------------     |
|                                 |
|                                 |
|                                 |
|                                 |
\---------------------------------/
```